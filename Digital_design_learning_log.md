# Digital learning log



## 02 July 2024

Today I reviewed the low power synthesis lab, which basically inserted clock gating into the flops to reduce power consumption.

And there is one key file to be inserted before synthesis, that is TCF (toggle count format).

this can be generated by running simulation using specific settings.


As suggested by the name, TCF records the signal toggling information where possibility of toggling and actual toggle counts for a siganl are recorded.

This flow can be illustrated as follows:

![TCF generation flow](./img/generating_tcf.6.1.1.png)


The command to generate this file is:

```tcl
dumptcf [-dumpwireasnet] [-flatformat] [-inctoggle] [-internal] [-output filename] [-overwrite] [-scope scope_identifier] [-verbose]
```

The detailed options explanations:

+ *-dumpwireasnet* requests to only dump ports in the pins section of the TCF file.
+ *-flatformat* requests to generate the TCF file in flat format. By default, the TCF file is generated in hierarchical format.

+ *-inctoggle* requests to dump TCF data for x and z transitions. By default, only transitions from 0 to1, and from 1 to 0 are included.
+ *-internal* requests to include internal nets and signals in the probe.
+ *-output* allows you to specify the name of the TCF file. The default file name is ncsim.tcf. This file is written to the directory from which the simulator was invoked.
+ *-overwrite* allows overwriting of an existing TCF file.
+ *-scope* specifies the scope of the hierarchy for which the TCF needs to be dumped. By default, the top-level scope or the current debug scope is the scope for dumping TCF.
+ *-verbose* displays informational messages during the generation of the TCF file.

example as here:

```tcl
ncsim> dumptcf -scope testbench.top -output tcf.dump -flatformat -dumpwireasnet

ncsim> run 3000 ns

ncsim> dumptcf -end

ncsim> run

ncsim> exit
```


### DFT synthesis

So apparently, if we are having untestable logic like ROM/RAM, shadow logic needs to be added around these blocks to finish the scan insertion.

First, do the generic synthesis.

Then add the shadow logic with the following command:

```tcl
add_shadow_logic -auto -test_control <Test_pin_name>
```

### Create SDC file


#### Define all the clocks


The command should be:

```tcl 
create_clock -name <clock_name> -period <period_number> -waveform  {rising_edge_time  falling_edge_time} [get_ports <clock_port_name>]
``` 


Then there should be clock latency set. There is no hard rule about how much should be set, but it needs to be realistic.

```tcl 
set_clock_latency 5 [get_clocks <clock_name>]
``` 


Now you should set up the setup and hold time.

The setup time should be 10% of clock period or larger, but max at 5 ns should suffice for low speed designs.

```tcl 
set_clock_uncertainty -setup 5 [get_clocks <clock_name>]
```



The hold time should be about the delay of an **INHDX1** in typical operating condition (1.8V/25C)

```tcl 
set_clock_uncertainty -hold 0.3 [get_clocks <clock_name>]
``` 



#### Timing of IOs

Now we need to add input and output delay

The document has suggested half way between the active clock edges is usually "the safe way"

Therefore for a clock period of 50, and a duty cycle of 50%, we would define 12.5 as the input/output delay.


```tcl 
set_input_delay -clock [get_clocks <clock_name>] -add_delay 12.5 [remove_from_collection [all_inputs] [get_ports CLK]]
set_output_delay 12.5 -clock CLK [all_outputs]
```


Setting the environment of the IO signals

Here the example assumed a weak driver from outside and a reasonable load. 

Where 0.4 pf is approx 2 mm of wiring in 180 nm.

```tcl
set_driving_cell -lib_cell INHDX1 [all_inputs]
set_load 0.4 [all_outputs]
``` 



Here the example prohibits the synthesis of buffer trees for some signals

```tcl 
set_ideal_network -no_propagate [get_nets RESET]
set_ideal_network -no_propagate [get_nets TEST_ENABLE]
```


#### Special consideration

If there is non volatile memories or any special analogue signals in the design, they should be left alone:


```tcl 
set_dont_touch_network [get_nets CP_OUT]
``` 


#### Power planning for XH018

General strategy for power planning is to leave all power routing in top 2 metal layers.


Top metal might be called MetMid or METTP.


Rings and stripes in general should have 10 um width, distance between stripes should be 250-350 um to ensure no more than 100 mV IR drop between rings and stripes.


Not sure what the following statement means, but it was included in the design guidelines:

Depending on placement of the supply pins from outside it is often a good idea to have the stripes closest to the supply pin locations 20 um wide for better power distribution.

Are the supply pins VDD/GND?


#### Other miscellaneous rules


I/O on the left/right of a block should use MET 1/3/5


I/O on the top/bottom side of a block should use MET 2/4/6


Avoid using top two metal layers for I/O pin planning


Spacing of I/O should be minimum 0.56 um for MET1 -> MET5, 1.12 um for METTP/MetMid


For clock signals (and signals belonging to a clock tree) an “extra spacing” (one empty routing track left and right of the clock signal) is a good idea to minimize crosstalk. Width and spacing of those signals are “standard” from the PDK.



## 03 July 2024


Was trying to look for the PC requirements for Genus synthesis solutions to check if the bottleneck is the RAM. But this is nowhere to be found and they have all been talking about CPUs.


Now checking the cadence product manual to see if I can get any answer.



Tried to go through the flow for my old bin ratio ensemble design again, but it seems a lot of connections has been disconnected or deleted.

Think it might be due to the fact that there is no memory IP, so that they have all been deleted.



## 17 July 2024


After another experiment with the single encoder, I believe it is not possible to compress everything in 10 um, it needs at least 2 rows with extended top and bottom space for pins placement and power stripes.


Now experiment again with double decker.

I managed to implement the double decker within 20 um????

The final layout looks like this:

![Updated layout of the double decker](./img/final_layout_of_updated_Double_decker.gif)

The dimension of the design is width: 112, height: 17.92


This design also passed the DRC check/connectivity check and timing check.


Have just extracted the RC, and exported the sdf file, will try to do a post-layout simulation.


By comparing the standard cell verilog library against mine generated from Conformal, I found that mine does not contain *Specify* block, which is seen by the example from the RAK.

But they are existent in the OA library for each cell in their functional folder, so I am considering copying the needed ones over for now as a temporary solution.


Eventually, I will need a verilog library for all the standard cells, this should be doable using a bash script.

But there are units that are not logged in the catalogue, which has been reported unresolved during simulation.

So what is "u_mx2", "u1_fd5" and "checkrs" that appeared in the logic definition of SDFRRQHDX1?

They are nowhere to be found, I should check XFAB portal later on when I have the access to see where to find the verilog for the library.


## 18 July 2024

Think I just found the VLG primitives directory for "u_mx2", "u1_fd5" and "checkrs".

They are listed in the folder 

"/eda/design_kits/xkit_root/x_all/diglibs/VLG_PRIMITIVES/v1_2/cadence_IC61/v1_2_0/VLG_PRIMITIVES"


After generating another big library verilog file, I am now able to do post-layout simulation with timing information annotated.

And I also noticed that the synthesis or PnR reorganised the scan chain for the design.

![The scan chain simulation after layout](./img/post_layout_simulation_with_timing_annotation.png)

